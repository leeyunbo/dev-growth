### [당근페이 백엔드 아키텍처가 걸어온 여정](https://medium.com/daangn/%EB%8B%B9%EA%B7%BC%ED%8E%98%EC%9D%B4-%EB%B0%B1%EC%97%94%EB%93%9C-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EA%B0%80-%EA%B1%B8%EC%96%B4%EC%98%A8-%EC%97%AC%EC%A0%95-98615d5a6b06)을 읽고 작성한 문서입니다.

**이 문서는 개인적으로 위의 포스트를 읽고 작성한 문서이니, 가급적 원문 포스트를 통해 학습하는 것을 권장드립니다.**

# "당근페이 백엔드 아키텍처가 걸어온 여정"을 읽고

## 1. 조직의 아키텍처

> Any organization that designs a system (defined broadly) will produce a design whose structure is a copy of the organization’s communication structure.
> - Melvin Conway

- 어떤 조직이 시스템을 설계하면, 그 조직의 커뮤니케이션 구조를 본뜬 형태가 된다고 한다.
- 우리 팀은 어떤 조직일까? 사실 내가 생각하기엔 완전히 망가진 커뮤니케이션 문화를 가지고 있는 조직이라고 생각한다.
- 우리 팀은 수많은 발송 도메인의 발송을 책임지는 GW 서비스를 운영하는 팀이다. 각 도메인은 굉장히 유사한 비즈니스 로직을 가지고 있지만, 외부 시스템과의 연동이 다르다는 이유로 완전히 다른 프로젝트로 구분되어 있다.
- 그렇다 보니 다른 팀원이 담당하는 도메인에 대해서는 거의 알지 못하는 상황이고, 심지어 리더도 본인이 담당하던 도메인 외에는 자세히 파악하지 못하고 있다.
- 이 상태로 시스템만 복잡해지다 보니 팀원들 간의 커뮤니케이션이 거의 단절된 상태가 되어버렸다.
- 활발한 코드 리뷰를 도입하려고 해도 각 도메인에 대한 이해도가 너무 낮아서 불가능하고, 공유 문화를 만들려고 해도 이해도가 낮으니 활성화가 안 된다.
- 결국 우리 팀은 망가진 커뮤니케이션 문화를 가진 조직이고, 그 결과물이 현재의 아키텍처라고 생각한다.
- 우리 팀의 커뮤니케이션 문화를 개선하려면, 결국 분산되어 있는 도메인들을 하나의 프로젝트에서 관리할 수 있는 아키텍처로 전환하는 것이 필요하다고 생각한다.
- 이를 통해 팀원들 모두가 하나의 프로젝트에서 협업할 수 있는 환경을 만들고, 자연스럽게 커뮤니케이션 문화도 개선될 수 있을 것이라 생각한다.
- 이 포스팅을 읽으면서 우리 팀의 아키텍처를 개선할 수 있는 방법에 대해서 한번 고민해보려고 한다.

## 2. Layered Architecture

- 우리 팀은 Layered Architecture를 채택하고 있다.
- 각 레이어가 독립적으로 존재하며 자신의 역할에 충실하도록 설계되기에, 계층 구분 말고는 딱히 신경 쓸 게 없어 빠르게 개발할 수 있다는 장점은 있다.
- 하지만 도메인이 늘어나고 각 도메인의 Service Layer들이 서로 얽히게 되면서 단점이 드러나고 있다고 생각한다.
  - 코드 복잡도가 기하급수적으로 높아지고, 기능을 변경하는 것에 대한 리스크가 점점 커질 수밖에 없다.
  - 특히 Service Layer가 비대해지면 테스트 코드 작성도 어려워지고 커버리지를 높이는 것도 힘들어져서, 결국 장애 발생 가능성이 높아진다.

## 3. Hexagonal Architecture

- Hexagonal Architecture는 우리 팀에 굉장히 어울리는 아키텍처라고 생각한다.
- 우리 팀은 수많은 발송 도메인이 유사한 비즈니스 로직을 가지고 있고 각 도메인이 다양한 외부 세계와 연동하고 있기 때문에, 도메인과 외부 세계를 명확하게 분리하는 Hexagonal Architecture가 적합해 보였다.
- 하지만 Hexagonal로 레이어를 나누는 것만으로는 부족하다. 만약 프로젝트가 하나인 상태에서 레이어만 나누면, 특정 발송 도메인용 어댑터 하나를 고쳤는데 상관없는 모든 서비스가 배포되어야 하는 상황이 생길 수 있기 때문이다.
- 당근페이도 바로 이 지점에서 고민했다. 헥사고날을 도입했지만, adapter 모듈 하나에 여러 도메인의 구현체가 섞여 있다 보니 배포 독립성이 깨지고 의존성이 오염되는 문제가 터진 것이다. 이를 해결하기 위해 그들이 선택한 것이 **모노레포 기반의 클린 아키텍처**다.

## 4. Clean Architecture & Monorepo

당근페이는 아키텍처를 크게 `bootstrap`, `core`, `infrastructure`, `library`, `platform`, `usecase`로 나눴다. 각 모듈은 독립적으로 개발, 테스트, 교체될 수 있다는 특징이 있다.

- **bootstrap**: 모든 레이어의 의존성을 조립해서 애플리케이션을 실행하는 최상위 모듈.
- **core**: 각 도메인의 핵심 비즈니스 규칙을 정의하는 모듈.
  - `core:{domain}:domain`: 외부 기술에 의존하지 않고 비즈니스 규칙 정의.
  - `core:{domain}:data`: core:domain 모듈에서 정의한 인터페이스 구현.
- **infrastructure**: 애플리케이션 실행에 필요한 기술적인 세부사항. (상위 레이어의 어댑터들이 이 모듈을 사용해 구현체 완성)
- **library**: Async, Logging, Retry 등 모든 모듈에서 공통으로 사용하는 횡단 관심사 모듈.
- **platform**: 도메인과 관련된 외부 플랫폼을 연동한 모듈.
- **usecase**: 사용자 시나리오 단위의 비즈니스 로직을 작성하는 모듈.

### 우리 회사에 적용한다면?
- 우리 GW팀은 수많은 도메인을 관리하고 있고 프로젝트도 다 나누어져 있지만, 우리의 최종 목표는 "하나의 통합된 발송 플랫폼"을 만드는 것이다. 그렇기에 모든 도메인을 하나의 프로젝트에서 관리할 수 있다면 어떨까 싶다.
- 요청 수신, 발송, 리포트, 통계 등 다양한 비즈니스 로직은 `core`에 작성하고, Netty를 사용한 TCP 소켓 모듈이나 RabbitMQ, DB 관련 로직들은 `infrastructure`에 둔다.
- 재시도나 로깅 같은 횡단 관심사는 `library`에, 각 도메인별 외부 연동 로직은 `platform`에 작성한다.
- `usecase` 모듈에는 도메인별 사용자 시나리오 단위의 비즈니스 로직을 작성하고, 최종적으로 `bootstrap`에서 의존성을 조립해 각 애플리케이션을 실행하는 구조다.

**만약 이렇게 아키텍처를 구성한다면?**
- 모두가 함께 담당하는 프로젝트이기 때문에 죽은 코드 리뷰 문화를 되살릴 수 있다.
- 나만의 불편함이 아닌 모두의 불편함이 되기 때문에, 개선을 위한 목표가 모두의 것이 된다.
- 문제가 발생해도 개인의 문제가 아니라 모두가 함께 해결할 수 있는 문제가 된다.
- 팀원 모두가 같은 목표를 바라볼 수 있기 때문에, 죽은 커뮤니케이션 문화가 되살아날 수 있을 것이라 확신한다.